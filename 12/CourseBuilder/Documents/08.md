# Chapter 8 - Testing

- Skill 22 - Data Tests
- Skill 23 - View Tests
- Skill 24 - Page Tests
- [Project 8 - Automated Tests - Superhero Test Suite](../project/8)

![Chapter 8](img/chapter-8.jpg)

---

### Types of Testing

Many developers undervalue testing and this often damages their effectiveness.
The best software engineers understand that testing is the key to amazing
productivity.


There are several types of testing that you need to do on every project.  
Neglecting any one of these will hurt, but missing all of them is a recipe
for disaster.

* Interactive system testing
* Automated system testing - Pages
* Unit testing of Data
* Unit testing of Views

## Interactive system testing

Create a map of the features in your code.  Keep it short but write it down.
Use this check list when performing interactive testing on your project.

Cover all of the data models in your system and the supporting views.  Start
with the full list of models and views and prune from there.  To do interactive
system testing well you should develop a basic user test that outlines all
of the workflows that the user will perform on your application.

### Test scripts

Test can be written to list actions and the desired results.  When bugs are
encountered they should be fixed immediately.  Why would you want to tolerate
know flaws in your system?  Bugs breed.

Run system with debugger enabled so that when you throw an exception you will be 
able to fix the issue.

Do not do interactive testing on your production server or you will be likely
to modify production data.  This is always a bad problem that must be avoided.
Run testing on a development machine where you are isolated from real world
consequences.


### Basic User Test

Manual test script of five views

* Home
* List
* Detail
* Edit
* Add
* Delete

When testing each view consider:

* How do you get to the view?
* What security rules are there?
* What contents appear?
* Is the view responsive?
* How does the application style appear?
* Test the outbound links.

Example of test script for Book Builder

    Author
        * List
        * Detail
        * Edit
        * Add
        * Delete
    Book
        * List
        * Detail
        * Edit
        * Add
        * Delete
    Chapter
        * List
        * Detail
        * Edit
        * Add
        * Delete


## Unit testing

Django has built-in support for testing each part of your code in isolation.
You can write tests as you create the product features.  Django provides a
method for finding and running all of these tests automatically.

The goal of unit testing is to test each code feature in isolation. This makes
it extremely easy to repair any test failure.  If a test executes 10 lines of
code it will be trivial to located the bug, but 1000 lines of code could take
hours to repair.

If you are spending time debugging, then it is a sure sign that you are not
writing good tests.  Tests take the place of debugging in a complex system.
Test also allow you to guarantee that your system remains working correctly
months or years after it was created.  Tests act as guardians of your code
quality.

There are an infinite amount of tests that can be done.  How much testing is
useful?


### Test Database

You can build tests that do not disturb your data in the database.
When you run Django tests, it creates and uses a new database for the testing.
Between every test it reverts to a clean database.  After all tests complete
there is no lasting evidence that anything happened.  This ensures that you 
can create, modify, and delete records without consequence in your database while
testing.

Each test runs in total isolation and can not be affected by the state of any
other tests.  Test are fully independent of the order they run it.


### SimpleTestCase

There are some kinds of unit testing that do not use any data records from
the database.  This usually involves business logic that does not require any
actual data.  For this situation Django provides the SimpleTestCase data model
class to use when creating your tests.  

SimpleTestCase provides a wrapper for writing tests.  Simply defining a class
that inherits from SimpleTestCase makes your test automatically discovered by 
the Django test runner.

tests.py

    from django.test import SimpleTestCase
    from .mycode import name_join

    class NameTest(SimpleTestCase):

        def test_name_join(self):
            actual = name_join('Abe','Lincoln')
            expected = 'Abe Lincoln'
            self.assertEqual(actual, expected)

To run all Django tests:

    $ python manage.py test

Each class defines an area of testing and each function defines one simple test
case.


### TestCase

In practice, most of the tests you will write will use data within your system.
This requires you to switch from SimpleTestCase to TestCase.  By inheriting
from TestCase you automatically get all of the database management for running
tests without writing any additional code.

In your tests you can use CRUD operations to create, read, update, and delete
records within your database.

tests.py

    from django.test import TestCase
    from .mycode import name_join
    from .models import Person

    class NameTest(SimpleTestCase):

        def test_name_record(self):
            actual = Person.objects.create(name='Abe Lincoln')

To run all Django tests:

    $ python manage.py test


### Asserts

TestCase and SimpleTestCase both define a number of different asserts.  You
could do all of your testing using the built-in Python "**assert**" statement.
But using the Django TestCase asserts give you a big advantage when viewing
the failing tests.  They print out a nice error message that usually tells you
exactly what went wrong.

Here are the asserts that I find most useful:

* assertEqual
* assertNotEqual
* assertContains
* assertIn
* assertTemplateUsed
* assertFail


## Unit testing of Data

Testing the data in our system requires that we try each of the CRUD operations
on each data type.  

CRUD Design Pattern

* CREATE - make a new record
* READ - get one or more records
* UPDATE - modify an existing record
* DELETE - remove a record


### CRUD Test

In its most basic form, we can test the data model by writing a series of test
case that follow a simple pattern.  This lets you write tests without actually
thinking about it.

tests.py

    class DataModelTest(TestCase):

            def test_operation_on_record(self):
                operation_on_record()
                actual = check_something()
                expected = "EXPECTED THIS"
                self.assertEqual(actual, expected)

Add

    Book.objects.create(title='Tale of 2 Cities', author='Charles Dickens')
    Book.objects.create(title='Iliad', author='Homer')

List

    Book.objects.all()

Detail

    b = Book.objects.get(pk=1)
    b.title
    b.author

Edit

    b = Book.objects.get(pk=1)
    b.author = 'Chuck Dickens'
    b.save()


In "Skill 22 - Data Tests" you will see examples and details of writing good
tests for your data models.


### Setting a Data State

Some tests require a know data state before the specific operation to be tested
is done.  A group of tests often shares the same data state as a starting point.

Django classes (TestCase and SimpleTestCase) provide a function for setting 
a particular data state.  The **setUp** function is run before each test is 
executed.

    class DataTest(TestCase):

        def setUp(self):
            create_test_user()

        def test_user(self):
            self.assertEqual(len(User.objects.all()), 1)

The **tearDown** function can be used to undo any things that are necessary 
after each test.


## Automated system testing

Uses the Django SimpleTestCase to ensure that no data is harmed during the test.

The Python library **requests** lets you call a remote server with an HTTP
requests.  Start by ensuring that requests is installed.

    $ pip install requests

Now we can write tests that fetch web pages from a running server.  This can
be a URL to any server.

    requests.get("https://shrinking-world.com")

Or you can hit the development server locally.

    requests.get("http://127.0.0.1:8002/book/3")

I have a test that runs regularly that visits a large number of URLs on many
different servers to ensure that the servers are live on the internet.  
Maintaining this test involves nothing more that maintaining a list of URLs,
yet produces great benefit for me.


## Test-Driven Development

During development setup a consistent workflow that balances different activities.

Create a To Do List that identifies work to be done.  This should show what 
items you expect to work on in the next day.  Every day you should work on 
different aspects of the development.  Many junior developers concentrate 
solely on the Feature of the app and neglect others.

Go for a balanced approach

* Test
* Fix
* Features
* Improve


### TDD Process steps

Test-Driven Development is the most efficient way to code because it prevents
debugging and leaves you with a battery of tests that are executed for years
to come.

During TDD you pick a single small feature to build and test.  All focus is 
tied to the one feature until it is fully complete and tested.  You commit
code after each iteration so it is impossible to break the system.

For each feature, you will create a small test that fails.  Ideally this test
will be two lines of code.  Your initial test must fail to demonstrate that
the test itself is detecting the missing feature.

    do_something()
    check_something()

The next step is to write the minimum code that will get the test to pass.
Ideally this will be a couple lines of code.  When the feature works you now
have the feature and a test to ensure that is continues working.  Commit the 
code and go on to the next feature.

Development Loop

* Select one feature
    * Setup an automatic test that fails
    * Write code to fix test
    * Commit changes

There are two ways that you can measure TDD effectiveness.  First, measure the
number of loops (features) that you can code in an hour.  With practice you
should be able to do about 60 loops in an hour.  

Another measure of TDD is comparing the lines of test code with the lines of
product code.  If you are doing true TDD the test code will be the same size
as the product code.


## Unit testing of Data

### CRUD Design Pattern
* CREATE - make a new record
* READ - get one or more records
* UPDATE - modify an existing record
* DELETE - remove a record

### CRUD Test

There should be a test for each of the CRUD operations.  Reading one or many 
records should be tested separately.  These tests should incorporate the
business logic that is related to the data models. These business rules show up
a corner test cases in our testing suite.

* List
* Detail
* Edit
* Add
* Delete


## Unit Testing of Views

There are five views that are possible for each data model in the system.
These follow the CRUD operations that we may wish to do.  Some of the views
may be eliminated in the system due to the business rules and constraints.
For example, it may not be possible to delete or modify certain objects.

Consider the example of the Basic User Test script for Book Builder. This is 
a good starting point for the views testing that we need to automate.  We 
will build one test case for each of the view types for each data model.

In "Skill 23 - View Tests" you will see examples and details of writing good
tests for your data models views.


### Data Views Design Pattern

Django supports each of the CRUD operations with a default implementation of
the view that is needed.  It then automatically creates most of the view logic.

We need to write a test for each of the views we use.  Create a consistent 
naming for each of the view tests.  This makes it easy to read the code and
look for missing elements.

* test_book_create_view
* test_book_detail_view
* test_book_list_view
* test_book_update_view
* test_create_delete_view


