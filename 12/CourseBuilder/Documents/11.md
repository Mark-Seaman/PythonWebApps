# Chapter 11 - Files and Documents


- Skill 31 - Reading and Writing Tables
- Skill 32 - Markdown Documents
- Skill 33 - Save and Restore Objects
- Demo - Book Builder
- Project 11 - Document - Superhero Docs

![Chapter 11](img/chapter-11.jpg)

---

## Overview

Many applications need to deal with files and documents.  Often the records in
the database are created by importing files from another system.  In this
chapter we will learn how to deal with different types of files.  

The code we have dealt with so far, allows users to create and modify the
records in the database interactively.  But often it is useful to gather data
from files to update the database. 

Exporting data from the database into files
is a great way to get data out of our system.
All of these uses require understanding how to create files from records and
records from files.


## Design Patterns

There are many different file formats that are used in modern application but
three formats are so common that we will explore them in detail.

* CSV (Comma Separated Values) - hold spreadsheet data as a table
* Markdown - document to convert to HTML
* JSON (Java Script Object Notation) - serial format for object interchange



## Working with Text Files

Our apps will typically have a database that is updated dynamically during 
the normal operation.  This data is trapped inside our system unless we do 
something special to export it into a document file.  Most apps will benefit
from exporting data from the database into files.

We could write a proprietary binary format for our files, but there is a huge
advantage to using a text-based format.  Version control system work extremely
well with text files.  Changes from multiple edits can be detected and merged
together.  The data compression for storage of all file versions is very
efficient.  And humans can easily read the text to ensure that everything is
good.

Git uses a standard difference detector that requires some sort of a text file
with frequent line endings to do a great job on the detection and tracking
of changes within our files.  There is little reason to consider exporting
data in a non-text format.


## Document File Formats

Choose a data file format that meets the specific needs of your application.
Always consider the possibility of exporting data to a file and then importing
that data back into the system from the same file.  This type of "round trip"
is often useful for some aspect of your app.

There are three types of formats that merit consideration as you select a
document format.  We will look at some detail at each of these formats in
this chapter.

* Spreadsheet Tables - If you have square data tables then consider using a
CSV file
* Markdown Document - If your data content is formatted text that will be
displayed as HTML then your documents should be written in Markdown.
* JSON Data Objects - If you want to export records from one or more database
tables directly then JSON files are the correct choice.


## Exporting Data

It is often very useful to export data from your system into a file.  This
file could be used by your app to save a copy of a data snapshot of a small
portion of the data or of the complete system.  There are many options that
are available.

You can also produce files that are given to user of your system.  These files
are Documents that can leave the system and be read back in at a later time.
They can also be entered into another system to reconstruct the data that
was present at the time of the export.

A Document is nothing more that a file that contains user data.  It can be
written out and read back in.  This idea of a "round trip" or "Export/Import"
is fundamental to being a Document.

Export Records to Document

* Write CSV - Rows, Columns (Records, Fields)
* Write Markdown
* Write JSON 

Import Document to Records

* Read CSV - Rows, Columns (Records, Fields)
* Read Markdown
* Read JSON


## Spreadsheets

Any time we are dealing with a rectangular table (with rows and columns) we
can store this as a CSV file.  The Comma-Separated Values data file format is
the generic way to store spreadsheet data.  All of the spreadsheet applications
have proprietary formats that store many other things, but the standard way
to save the data is in a simple text file.

Conceptually every database table can be stored in a CSV file.  Each record (row)
produces a line of text in the file.  Each field (column) in the record can
be represented delimited by commas.

CSV file format is easy to read and write and version control systems can easily
merge multiple edits together.  Consider the following example of chapters in 
this book.

    1,Development Tools,4466
    2,Application Hosting,6032
    3,Basic Application,3640
    4,Views,3814

The columns represent the chapter number, then the chapter title, and
the number of words in this chapter.  It is easy for a human to verify that
this content looks reasonable.  In fact, this file can be opened directly with
any spreadsheet app.


## Markdown Documents 

Writing in HTML can be awful tedious.  Getting the tags to match can be 
problematic.  If you are going to write a lot of content then consider developing
the text in Markdown.

Markdown is a very simple language that is converted directly to HTML.  
It is far for readable than HTML and much more efficient to write.  I use only
a few basic constructs to give some basic formatting.

    Types        Markdown     HTML

    headings    #               h1   
                ##              h2
                ###             h3 
    bold        **bold**        b
    list        *               ul, li
    link        [Link](url)     a
    image       ![text](src)    img

You can go a long way with just these few basic constructs.  When you need
to, you can add HTML text directly.

If your documents look like HTML pages then consider using Markdown as the
Document format that you read and write.


## Save and Restore Objects

There are several situations where it is useful to save raw data objects into 
a file.  If you want to destroy and rebuild the database you can export all
the objects, recreate the database then bring back the objects as they were.
This is very useful if you are trying to move data from one system to another.

The key limitation of this practice involved the "primary keys".  When the
objects are exported, the primary key represents the identity of each record.
When you import data into the system there can be no conflicting objects.
The same object can be imported more than once, but other objects must not
share the key.

In practice, this limits you to importing data objects into a fresh system to
set the database to a particular state.  It can be very useful during testing.

Do not export objects on a running system and expect to read them back in 
successfully because the app will continue to create new objects that will
be in conflict with the saved ones.



