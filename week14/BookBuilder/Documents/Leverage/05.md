# 5 - Architectural Leverage



> "Architecture should speak of its time and place, but yearn for timelessness".
> ~ Frank Gehry

---

High quality architecture is the direct result of applying good design
principles and practices to solve the problems at hand. Without a great
architecture you have nothing to leverage. If the old solution barely meets the
needs then it can't be extended to meet a different set of needs.

If you don't trust the current architecture then don't try to leverage off of it
to build something new. You will invest far more time than it is worth, and when
you are done, you will have something that is no better than the first version.

Building systems from a fresh perspective, with the knowledge of the old system,
is far faster than trying to convert an old system into a new one. A system 
that costs 1000 hours to build can be rebuilt from scratch in around 300 hours.
This is because you already have solutions to 70% of the problems you will 
face. Design leverage is often far more powerful than code leverage.

The quality of the software architecture directly depends on the strength of the
interfaces. Design is all about the interfaces between the components. A
reusable architecture has well-encapsulated components and standard interactions
between those components.

A poor architecture has very weak components and lots of complex and custom
interactions between them. A weak architecture doesn't even meet the needs
of its initial use and breaks entirely when you try to extend the business
needs to a second generation solution.


## Need for Reusable Architecture

Leverage of the design is perhaps the most important kind of reuse that is
possible. Reusing key design elements enables other types of reuse throughout
the life cycle. However, when designs can't be applied to new development,
opportunities to build on other elements are thwarted. When the designs can be
recycled it is quite natural to use the product definition, technology,
implementation components, and tests to the fullest extent.

Maximizing the design leverage is the best way to optimize the overall leverage
of the project. Pay special attention to the way that each generation of project
can be built upon the design of its predecessor. High reuse of the design can
lead to ten times the productivity and one tenth of the cost. The stakes are
high so the effort spent to develop greater skill in this area will be well
rewarded.


### Design is the Heart of Software

Design is the essence of software development. Engineers solve problems by
creating solutions that are implementations of design ideas. The code embodies
the designs and applies it to the real world. The underlying technology supports
the design but doesn't solve the problem directly.

A weak design will lead to a poor implementation and an inappropriate use of
technology. However, a strong design can produce a great product that will stand
the test of time. A good design is not only critical to the current solution,
but can be used as the basis of many other future products. Design leverage
lets us get long-term benefits from each design that we create.

Leverage is a test of your design quality. Weak designs can't be effectively
reused. The assumptions that were used in creating the original design won't
hold for other applications. It is necessary to modify the existing design to
accommodate new assumptions. This is where the design quality is revealed. Poor
designs are rigid and can't be adapted to new use. Any design that can be easily
applied to new situations is strong, by definition.


### How Much Do You Leverage?

All of us want to achieve a high degree of leverage of our designs. Why build  a
system that we had no intention of extending? But the reality is far from
encouraging. We often get far less leverage than we expect. Here are several
viewpoints that are useful to determine the design leverage that you are
currently achieving on your projects.

Engineering is done to solve problems. Each project solves a collection of
problems. An inventory of solutions can be used to solve the next round of
problems that need to be solved. One way to look at your leverage is to evaluate
how many new problems are solved by applying existing solutions and how often
you need to start from scratch.

Another way to evaluate your leverage is to compare the software budget required
to build a new version of your product. This is a good indicator of the overall
leverage since leverage is directly tied to the amount of design reuse.

A third way to think about design leverage is to measure the size of your
inventory of design tricks. Do you have a substantial and growing list of
solutions for common problems? Are these applied to new problems by each team
member or are they disregarded? On the typical project, how much new learning
must occur? Each of these unique viewpoints can be useful to assemble an
accurate picture of your design leverage.


### High Leverage is Possible

Is it even possible to reuse designs? Many question whether it's practical to
build multiple generations of design without starting from scratch. There are
several factors that work in our favor. Every company building software works in
some kind of a customer domain. This means that we are solving similar problems
with each product development. Leverage is possible and required in order to
stay competitive. We must learn effective ways to utilize our past engineering
work to optimize our next product.

Creating solid designs for our most common problems is an important part of
building strong business value. These designs embody understanding of the
customer needs. Over time we build a deep knowledge of the domain and the
software that serves those customers. The designs demonstrate the subject matter
expertise we possess.


### Building a Practice of Design Reuse

Design leverage is highly desirable, but it is not automatic. It requires
learning a set of competencies and applying them every day. It takes discipline
to follow through on the practices that lead to success. Initially we need to
focus on learning the core competencies that produce good designs. It is
critical to set goals for the leverage that we expect to achieve. Modest goals
will take a small amount of effort while ambitious goals may require a Herculean
effort.

Make an attempt to quantify the amount of design leverage that you are achieving.
This will have two benefits, it will help you set better goals and it will help
you to justify the improvement efforts. When people begin to see the benefit of
the work being done they can get very motivated to support it. A regular review
cycle can also make your work more visible to the larger organization.


## Evolutionary Design

It is impossible to predict the details of the design that will emerge at the
outset of a new project. So instead of putting effort into guessing at the shape
of the future you should learn how to build systems that are inherently
flexible. Strong design of components can emerge incrementally by applying
constant refactoring at the same time that you add features. This overall
process of evolutionary design lets you begin development in a direction that
will be refined as the system is built out.

Leverage of software architecture results when sound engineering is coupled to a
flexible plan. Trying to do too much planning up front will undermine the
leverage opportunities. Creating a rigid architecture that doesn't anticipate
the types of variations that future system will require will also block
leverage. Refactoring is an essential skill that must be used daily to
successfully evolve a design without excessive bit rot.


### Lightweight Planning

Traditionally, software projects relied on lots of up-front planning at the
project and architectural levels. This assumes that everything is known at the
start of the project. The net result is that the most critical decisions on the
project are made at a time of maximum ignorance. The mistakes made early in a
project will continue to haunt you throughout the duration of the project. These
will ultimately prove to be the costliest mistakes.

Avoid locking in plans that are built on untested assumptions. While there are
areas of uncertainty, the focus of planning must be to verify reality in these
areas. If technical or market feasibility is a question, find those answers
first before creating an elaborate plan that assumes an answer.

In practice, the design and planning can proceed in parallel with the
investigation of underlying feasibility issues. But the design work must remain
flexible, especially in areas with untested assumptions. Focus on the essential
aspects of the design while allowing detailed work to be adjusted later.

This argues for a top-down design. You may know enough now to know that you will
need a transaction processing system, but may not know enough to design the
nuances of the multi-stage commit and rollback. Save the unknown details for
later commitments.

One way to proceed with the design work is to focus on the problems that must be
solved first. This creates focus on the essential elements and avoids
unnecessary requirements. It also provides a natural means of selecting the most
important problems first. The priority of each problem should be proportional to
the impact that it has on the project if left unsolved.

Any issue that undermines (or calls into question) the validity of the project
overall must be addressed before anything else. The second tier of problems  are
those that block overall progress in another area. Sometimes, problems must be
solved in a certain order and relatively minor issues can stop progress until
they are addressed.

Keep your plans lightweight. The plan is only useful if it enables and
accelerates real work. No customer will execute your first plan perfectly so the
only thing that matters is how your plan will be converted into a running
product. Heavy plans slow a project down.

For years we were expected to write a Product Marketing Requirements document,
an Engineering Requirements Specification, an Internal Requirements
Specification, and a Internal Maintenance Specification. Every project started
with an extended period of time to write the hundreds of pages of documentation
required. The purpose of this documentation was to reduce risk in the project by
making the product development predictable. The rationale was to get the unruly
engineers to commit to what they would eventually build and prevent them from
wandering aimlessly toward some undesirable product goal.

The tragedy of this approach is that these documents are never even close to how
the ultimate product looks. There are so many essential elements that are
unknown that any attempt to predict every detail hurts the project. Not only is
the effort to write the documents wasted, but the presence of the documents
limits the scope of the solution.


### Building Flexibility

A flexible system is resilient to change. Design leverage is about adapting
existing designs for new purposes. This requires that the system be easy to
change. Rigid architectures don't change. The initial needs of the design may
be easily met but when you start trying to solve a slightly different problem
it takes an unreasonable amount of effort to make the changes.

If the design is healthy, a small change is easy and a big change is possible.
With a bad architecture, a small change is hard and a big change is impossible.
Any change that can be described in six words should be implemented in one line
of code.

It should never take 100 lines of code to add one employee record or calculate
an order total. If an idea is easy to express it should be easy to implement. If
the change is hard then the design is not quite right. Healthy architectures
change daily.

We all want flexible designs but flexibility comes from flexing. The design will
only honor those constraints that you have forced it to accommodate. If you need
a function to take either integers or floating point numbers then you have to
design and test those capabilities in. Never assume something works until you
have an automatic test that verifies it - testing is the way that you flex a
software system. You can't say that your code runs on Mac and Windows until you
actually run it on those two operating systems. Your code is not flexible
across versions of Python unless you test daily on at least five versions of
Python.

If you are building a framework or toolkit that is expected to be used in an
environment quite different from the design environment, you must test the full
range of operations that might be done by all of your users.

In order to get the benefit of flexibility you must pay the cost of flexing the
code. Decide which types of flexibility you need and design a method of
guaranteeing that you have achieved that degree of flexibility.

I once worked on a large platform for image manipulation. Our products needed to
provide consumers with solutions that would let them edit, organize, enhance,
and print their digital photos. The problems that would need to be solved
eventually were open-ended - many different requirements would need to be
handled by our image manipulation system.

In our case, we built an architectural model built around the concept of an
image pipeline. Image data would come into the system and a series of
transformations would be applied to it and then a new image would be exported.
This problem begs for an architecture that accommodates a variety of image
transforms.

The data flow and control flow are set by the architecture but the exact
transforms that are needed were supplied as a parameter to the image processing
engine. In other words, the flexible dimension is the transform algorithm -
everything else is fixed.

Design future flexibility, but stop short of implementing it until you are ready
to use it. We can lay a foundation that will meet the future needs of our
product but it doesn't need to be fully built out. We should always wait for the
business justification before we build features into a product.

As the system matures you will need to build out the full feature set.
Addressing secondary features too early in the development process can actually
harm the design. Optimize your system architecture for the essential features,
then extend the design to handle the secondary features next.

Never build a feature just because you think you might need it someday. Wait for
a clear business need then try to get it deployed quickly. In my personal work,
I try to stick to the "2 day rule". Don't work on anything that won't be needed
in the next couple of days. Of course, as your project scales up you need to be
flexible, but the overall goal is to decrease work in progress.

Designing the ability to accommodate future features is important. The cost 
of design is usually about a tenth of the cost of the full build-out. It is 
best to anticipate the future needs within your architecture without incurring
the full expense of building, testing, and maintaining the code.


### Levels of Design

Think about your design in layers of detail. Your design should have a one page
description that everyone on your team can recite from memory. This plan should
define all of the necessary major input and output elements. It should also
break down the top level system blocks that you intend to build. There should
be between three and five subsystems that will run your product.

It is important to have a simple to understand block diagram of your system in
order to discuss the structure with people both inside and outside of your
project. Many engineers are unable to discuss the system without bringing up all
of the gory details. These are especially confusing to non-technical people and
these discussions can decrease trust.

Within each of these subsystems you will want to use the same approach. Let a
one page summary illustrate the core input, output, and functional breakdown.
Then extend this into as much detail as you need. Write all of the documentation
that you will actually use. There is no time for writing "Write-only Docs".

Every system should be documented with at least three levels of detail. I like
to call these:

* Product - overall design to address how external players interact with the whole
* Subsystem - highest level building blocks define all core interfaces
* Module - smaller building blocks that define source code modularity

Below these levels of structure we find the source code for the modules. Each
module should also be well-structured with sub-modules and functions. When you
get to the modular level you should favor API documentation that is either built
into the code or extracted from it.

Paper docs are difficult to maintain so minimize the amount that you write.
Documentation that is embedded in the code is maintained as a part of the source
code. Better yet, use great naming and let the source code be the definitive
reference. After all, your source code will be thoroughly tested daily.


### Essential Design Practices

Good design involves art and finesse. Less experienced engineers tend to
overbuild their systems. They put in far too many features early on and build
things that will never be used by a real customer. Since time is spent building
extraneous features there isn't enough time to build essentials so they end up
cutting corners in critical areas that threaten to undermine the quality.

Focus on the essential elements first. A trick to find out what is truly
essential is simply to limit your To Do list to five items. If you only got to
implement four features today, which ones would you choose? This technique can
be applied repeatedly. Once you finish the next five essential items you can
select another five.

Making a list of a hundred features to implement causes you to lose focus. A lot
of the power of Scrum comes from the increased focus on the essential. A Sprint
is defined for a fixed time period that forces the developers and the product
owner to focus on the essential.

Select a few tasks and do them well. Then stop as soon as you have achieved an
acceptable result. You can come back later and make it even better but the next
action you do should be the most important thing that you can do.

Don't address a secondary issue when there is something of far greater
importance that is waiting. You should be constantly asking yourself, "Is this
the best way to spend the next hour?" Give special consideration to design
issues that may be blocking the activity of others.

Draw a map of dependent activities. It doesn't need to be as complex as a PERT
chart. It simply needs to list which design tasks need to be done in order to
allow other tasks to stay on track. Then it's good to set dates for expected
delivery of that feature.

The graphical view of a schedule isn't nearly as important as establishing the
key hand-offs that must take place. Project planning typically involves the
task decomposition (with resource planning) and dependency management (with
deliverables).

Establish a list of the most critical problems to solve. Then give your team a
budget for solving each one. For example, assume that your system needs to
authenticate users in order to use your web site. This problem could be solved
by a competent engineer in a day. Of course, if you already have a reusable
design then you can set a limit of an hour for this task.

Work off a list of problems and make sure that everyone on your team is
contributing to solving the most important issues first. A full team can deliver
a phenomenal amount of value when you focus the effort. Limiting the time
allowed to solve problems is an excellent way to avoid overbuilding a system.

My best development experience was working with a team of five engineers on
digital imaging software. We built applications for camera unload, image editing
and enhancements, photo printing, scanning, and sending photos. We did the work
of over ten people because we only did the essential tasks. A project that has
clear priorities is much more likely to be successful because all of the work
can be focused in the right direction. A project that doesn't have a clear sense
of what is important will struggle from the beginning.

The design must be built according to the business priorities of the project
itself and the design effort can be a catalyst in understanding. Sometimes a
project lacks clear priorities because the business partners are unsure about
the overall business direction. In this case, the software project must develop
a software plan that has verification steps for the business ideas as well as
the technology. Early prototypes of product ideas can heavily influence the
goals of the overall business by answering some questions and asking others.


## The Prime Directive - Encapsulation

At the beginning of the computer era programs were written as giant lumps of
logic. People quickly figured out that this was a poor way to write software.
Encapsulation and abstraction are powerful concepts that allow humans to
understand complex software.

Great encapsulation strikes a balance between robust and powerful mental models
and simplicity. They are cohesive blocks of logic that remain well-isolated from
each other. These components provide building blocks that can be used to
composite sophisticated applications. The key is to make it easy to understand
the external surface (API) of a component without having to understand its
internal details. This is the key to encapsulation.


### Mental Model

Good designs have at their heart a strong mental model for some type of data. An
abstract model defines how the item is represented in the computer and how it is
acted upon. Some models are simply calculations while others are persisted in
some form of saved state.

A good model must be defined before code is created to implement it. Some
engineers rush into writing software before they have adequately thought
through the underlying issues of using it.

Our goal is to maximize the leverage. A model encodes a way of thinking about
some object within our system. A great model will last for years. The models
themselves my end up going through many different implementations over time,
and yet, be essentially the same.

A mental model must address the following concerns:

* Data automation
* State transition
* Data flow
* Control flow


### Simplicity

The most powerful models in our system are the simplest to understand. Everyone
knows what a bank account does or how to assemble an order from line items. It
should be easy for you to make a list of the top 20 data types that are
important in your domain. Here are some examples to get you going:

* Users and login credentials
* Web pages
* Images
* Music files
* Documents
* Accounts
* Transactions
* Graphics (lines, points, shapes)
* Web resources (CSS, JS, HTML)
* GPS coordinates
* Maps
* Aircraft positions and velocity
* Star coordinates

The specific nature of the data types vary greatly with the domain that you work
in, but it should be easy to assemble a list of your most important data types.
This is an opportunity for huge leverage. Building an arsenal of data models
will put you well on the way to building reusable software applications in a
fraction of the time.

A simple design should be expressible on a napkin. Build a catalog of reusable
designs that meet specific situations. Use the ready-made solutions to address
problems as they appear. Parameterize the solutions too maximize the leverage
opportunities.


### Isolation

Changes in one part of the software shouldn't have a ripple effect throughout
the rest of the code. If this happens, it becomes impossible to reason through
how a change will affect the system as a whole. Over time people will stop
making changes out of fear of inadvertently breaking everything, even when
changes are desperately needed. This causes the software to rapidly decay and
fall into disuse.

Data hiding prevents exposing the details of a module to the modules that use
it. Assumptions about the internal details shouldn't affect how the system is
used. Otherwise, the two modules are coupled in an inappropriate way. Modules
must remain as independent as possible in order to protect leverage. This means
that each interface is as narrow as it can be. Each model should have strong
cohesion internally and minimum coupling to the outside world.


### Building Blocks

Our goal is to create a set of building block that can quickly be assembled into
applications. This strategy requires that each component be encapsulated so that
it is minimally connected to all others. Changes must be contained within the
component by minimizing the coupling between the components.

Making components that are useful across a broad range of applications requires
extra effort compared to only satisfying the needs of a single use. Don't try to
generalize a component too early. Initially you should focus on the specific
needs that are in front of you.

With each new usage of a component you can generalize it a little bit. Over time
it becomes very general but with this incremental approach you can amortize the
cost as you go. Invest around 10% of the effort in generalizing a component each
time you need to use it.

Consider the following example. Cindy needs to add a mortgage calculator into
her app. To address all of the different type of mortgages she estimates that it
will take her about 40 hours to build. However, the needs of the current app can
be met with only about 10 hours of effort. She solves the simpler problem and
avoids spending 30 hours on a solution that isn't needed yet.

But the next three apps require modifications that the simple solution didn't
address. Each app requires another 1-2 hours to enhance the limited solution. In
the end, she produces a general purpose tool that is just good enough to meet
all of the needs at a fraction of the cost.

Measure the number of problems that you solve using an existing solution and
also measure the number of time that you are required to build a solution from
scratch. Next, look at the number of times you have reused a particular
solution. The average number of reuses should be at least five while the
percentage of problems that need original solutions should be less that 20%.
These ratios will show you what your true reuse looks like.


## Practices for Design Leverage

High quality designs are the product of great engineering practices. There is a
short list of core techniques that must be mastered to consistently produce the
highest quality designs. Within a team you need someone that thoroughly
understands these disciplines and can teach them to the rest of the team. There
is no short cut - you must learn and apply these techniques each day.

* Refactoring of legacy code
* Defining interfaces - robust and minimal
* Encapsulation - defining component boundaries
* Building domain languages - allows for testing and automation
* Test-driven development - allows evolution through refactoring 


### Refactoring

The most important design skill to master is code refactoring. This allows you
to work with an existing body of code and apply design changes. Evolutionary
design requires constant refactoring. If a design can't be modified in-place
then it will can't evolve. Therefore, refactoring is an essential skill for
working on the design throughout the course of the project.

Let's look at a typical evolution of three product generations to see how this
works. The first product is built from scratch with very little forethought to
the future. The second application is built by leveraging the first. During this
development certain reusable components are identified and encapsulated for
later use. The third generation product builds on the second and additional
generalizations are made to the code.

The best architectures emerge from successfully refactoring the common
functionality out of several different applications. Even though each
application was created as if it is the only one, two applications within the
same domain will share a lot of common design elements.

A skilled software architect will discover and identify these common elements.
Then they can be extracted into a framework that contains the general logic
without any of the specific details from the original implementations.

Once the refactored framework is stable, the original applications are converted
to use the new framework. This is a fairly mechanical process since the design
elements originated from the specific applications themselves.

Now the framework can be used in a third implementation. This code won't contain
the application-specific logic that the first two implementations had because it
utilizes the generalized logic right from the start.

Inevitably, the third implementation will also require extensions to the general
framework. All three applications (and the ones following) will influence the
framework by adding additional features. Each new implementation will continue
to influence the design, but to a diminishing extent. Eventually, the design of
the framework will stabilize.

The end result of this approach is a generalized architecture that is minimal,
robust, clean, and well-factored. It can live for many years and service tens or
hundreds of projects for decades. Django is a good example of this process. It's
a web application framework written in Python that evolved in precisely this
way. Several custom apps were developed and each time the common elements were
refactored a robust framework began to emerge that developers outside the
original team can now use.

This is a high-level description of what happens in an evolutionary design. A
rigid design is built at one time for only one purpose but a flexible design is
more organic. A design built in a day may last for two years while a design that
evolves over many years can live forever. For maximum leverage, look for a
design than can morph into something that goes far beyond the original intent.

Many engineers try to create a generalized solution for problems too soon. The
reasoning is that they know eventually that certain other problems must be
handled and they believe that it will cost extra work to do it later. This is
almost always a mistake. It assumes that you know enough about the future
problems to anticipate which direction the overall design will take.

Let the general solution emerge over time. This organic growth occurs as
features are added and the common elements are refactored into the base
framework. Eventually a strong solution emerges that is truly optimized to
address specific problems.

The features of the specific app should be built incrementally. The quickest way
to build any application is one line at a time. One line of test code - one
line of product code. Then pause to remove any duplication that you see. This
process of baby steps will let you move extremely quickly.

Refactoring is the most important design skill that you have. It lets you
continue the design work throughout the project rather than restrict the design
to only the start of the project. I highly recommend that every engineer
understand the content of Martin Fowler’s book, “Software Reuse”. You'll find
that refactoring is a survival skill that prevents bit rot and protects your
software investment.

Refactoring is a strategic tool that allows you to incrementally improve your
design to match the changing business conditions. No matter how brilliant your
designer are they can't see into the future.


### Design Patterns

The goal of design patterns is to have a standard way to solve common problems.
When you encounter a situation that looks like THIS, the best way to handle it
is THAT. Build a catalog of these design patterns that work for the situations
you are most likely to encounter. Your catalog should also include style
guidelines, and programming idioms. A framework is an application that embodies
many design patterns. Understanding the principles behind design patterns gives
us the ability to build stronger frameworks.

A healthy software organization will have the right balance between autonomy of
the individuals and good leadership. A technical leader must oversee the
architecture, work on reviewing the patterns, and the performance of the overall
system. Creating a public discussion for the top ten design patterns in your
organization is one way to encourage pattern reuse throughout your team. Ask
people to make contributions to the patterns. As people understand the
advantages of various patterns they will naturally propagate best practices
throughout the organization.


### Interfaces

An interface is the connection between two parts of the system. Interfaces and
components are the primary design elements. Multiple subsystems (or components)
are connected to each other by interfaces.

A well-designed component is tightly connected on the inside and loosely
connected to other components. In fact, it is so loosely connected that we can
draw an arrow between two components and describe the exact range of
interactions that are possible.

Every interface should be tested because, collectively, the interfaces represent
the primary interactions throughout the design. Test all of the assumptions that
occur on each interface. For example, assume we have an employee model with a
name and ID. The interface to employee should contain things like get the name
and ID, add an employee, update this employee, and delete this one. These
operations are an encapsulation of the idea of "employee" in our system.

Each operation should have test cases that make sure that our employee does what
it is supposed to do. Test the employee interface by making employee do
everything it is designed to do. Each interface represents some kind of story.
Embody the possible operations as test cases or story elements.

Examples:

* An employee is added
* The name and ID are retrieved
* The employee is updated
* An employee is deleted
* A list of all employees is created

Write one or more test cases for every story. You may also choose to create a
language that allows you to create your own scenarios. This is a very easy way
to automate an interface, allowing you to verify key things about the
interactions.

Being able to predict the operations that are present in a given interface
provides a significant advantage. The reader can spend more time thinking about
the problem they are trying to solve if the calling syntax is familiar. Design
interfaces that are patterned after the software other people are comfortable
with already.

One example of a standard set of operations is the CRUD API. Implementing an
interface to persistent storage begins with defining the implementation for
Create, Read, Update, Delete. Additional operations can be added as needed. We
can think of a set of standard operations as a design pattern of sort.

Another example of a standard pattern for API definitions is the file interface.
This usually is built around a programming model with Open, Read, Write, Close
functions. Notice that the operations themselves imply a work flow (involving
both control flow and data flow).

As you encounter the same operations repeatedly you should build it into a fully
defined design pattern. This lets you address many of the decisions that are
inherent in the pattern. Standards leverage learning and help your team avoid
floundering when trying to apply the learning. Our key goal is to have our
understanding of each problem transferred with the highest possible fidelity.

An engineer can be considered fluent in a language when they no longer have to
think about speaking it. Fluency is the result of the interface quality and the
familiarity that an engineer has with it. Leveraging common design idioms speeds
up the process of becoming fluent. The goal is to minimize the amount of effort
required to utilize all of your key interfaces - they should be entirely
intuitive.

Some APIs (application programming interfaces) have rich and highly structured
vocabulary that can be rightly described as a language. Other interfaces have
nothing more than a stack of function calls that take complex parameter
arrangements. These interfaces can often benefit from a simple text language
that can perform the major functionality of the interface.

Begin by keeping the language simple at the beginning. Let it grow as it needs
to, but do not add that burden at the start. Define the key actors in your
system and make these nouns. Then define the operations that are appropriate
for that type of data. Now you have a simple language for your system.

Build strong data types with standard operations. These should leverage the
common understanding and be intuitive to the engineers. Concepts must be simple
and obvious. Create simple phrases: "send email me@here.com", "customer update
list", "missile launch", "build pdf mybook.pdf". Create a language that matches
the customer problem. Minimize the need for modifiers by letting many of the
parameters default to reasonable values.


### Domain Languages

In Martin Fowler's book on Domain Specific Languages, he describes the
principles of DSL and how they should be used. I highly recommend this book if
you're interested in a deep dive into DSLs.  But even if you don't read the book
you can benefit from the concept. It's often enough to just define a simple
language for talking to your system - it doesn't need the full properties of a
DSL.

Implementing a design language gives you endless possibilities for automation
and testing. All of your core functionality can be exercised from remote
clients. A web app can have a command-line controller and a command-line app can
have a web interface. Most of this flexibility comes as a direct result of
creating a strong interface language.

Recording commands that flow across the interface can be done just by logging
the text of each command as it is executed. This log is useful for humans to
study the control and data flow across the interface. A tremendous amount of
insight can be gather by watching the actual traffic flow.

It may also be useful to read the log and pass the same commands back across the
interface at a later time. This gives the application a record and playback
level of functionality which may become central to the daily operations of the
business.

Recording commands can be done by capturing the commands that are sent to an
interface. Setting reasonable defaults lets you reduce the number of parameters
that must be recorded for each command. Try to limit the recorded attributes to
two or three. Think about the recording as building a command history that can
be used as a script.

Record and playback becomes really useful when you can save and restore state.
Capture the snapshot of the system or a portion of it, then create the ability
to read that same state directly into the current system. This can now be used
as a setup for a testing scenario. Use the following sequence to build a test
scenario. This process will net you a robust platform that you can build an
entire system upon for regression testing.

* Setup starting state
* Run some automation scripts while capturing commands
* Confirm new state
* Reset the starting state and confirm that changes are removed
* Playback captured commands
* Confirm new state
* Reset the starting state and confirm that changes are removed

Imagine if you could talk to your system. You could instruct it to go through a
sequence of events and then confirm the status of the system as a result. This
is easy once you have built a simple command language. You can add users, create
orders, list accounts, feed elephants, launch missiles, and reset systems.
Whatever your system does can be easily scripted. Think of the new opportunities
that this opens up for automation or testing. The only remaining work is that of
authoring stories.

Start by identifying the characters and actions that are in your stories. Build
a language that lets you express the most important scenarios. Pattern your
story line to be Turing Complete:

    Initial State + Transition -> New State


Build domain stories that match the things that your system can do and focus on
the most important tasks first. Then grow into other areas that you wish to
express. Often, you will not get that far because the benefit of building it may
not justify the cost. There will be a clear advantage of building your core
functionality into a automated system - this will be your primary testing
infrastructure.



## Best Practice #5 - _Create components with strong encapsulation and standard
interfaces._



***Problem***<br>
Design leverage is central to overall reuse. If a design is preserved it creates
opportunities for reusing the technology, the definition, the implementation,
the testing, and the planning. The tendency to abandon designs and start over
each time is rooted in the mistaken belief that all designs are fragile and only
live for a short time.

Many engineers have had bad experiences trying to leverage weak designs in
legacy code. They have drawn the erroneous conclusion that design leverage is
not really practical. Poor design practices result in weak designs. If the
existing code base is riddled with technical debt then design leverage is
impossible. But if the code base is sound then the design should be flexible.

If the design can't be modified to meet the new design requirements then there
is little opportunity for other types of leverage. If this happens the product
cost will be comparable to the original cost of development. This means that the
business value of the system is quite low.

***Solution***<br>
Companies are not doomed to reinvest repeatedly in zero leverage software
development. Any team can learn the skills required to build well-designed
software. Best practices leads to solid designs which support evolutionary
design. Strong encapsulation leads to components that are reasonably independent
of each other. This in turn makes design leverage possible by isolating the
affect of design changes to single components.

Core practices can be learned by any team that desires more leverage. A single
engineer within the team can learn and teach others. An entire team using these
best practices will increase the degree of leverage within the project and
dramatically lower the development cost.

***Next Steps***

* Measure your current leverage using: % new solutions, budget size, 
inventory of tricks, required learning
* Set goals for desired design reuse
* Assess your team competency in these practices:
** Encapsulation
** Refactoring
** Interface design
** Languages for your domain
** Record and playback
* Select one key interface to overhaul
